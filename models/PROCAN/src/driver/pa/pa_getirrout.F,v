head     1.1;
branch   1.1.1;
access   ;
symbols  CMAQv4_7_1:1.1.1.1 AMAD:1.1.1;
locks    ; strict;
comment  @c @;


1.1
date     2009.12.10.15.45.48;  author sjr;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2009.12.10.15.45.48;  author sjr;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@
C***************************************************************************
C  Significant portions of Models-3/CMAQ software were developed by        *
C  Government employees and under a United States Government contract.     *
C  Portions of the software were also based on information from non-       *
C  Federal sources, including software developed by research institutions  *
C  through jointly funded cooperative agreements. These research institu-  *
C  tions have given the Government permission to use, prepare derivative   *
C  works, and distribute copies of their work to the public within the     *
C  Models-3/CMAQ software release and to permit others to do so. EPA       *
C  therefore grants similar permissions for use of Models-3/CMAQ software, *
C  but users are requested to provide copies of derivative works to the    *
C  Government without re-strictions as to use by others.  Users are        *
C  responsible for acquiring their own copies of commercial software       *
C  associated with the Models-3/CMAQ release and are also responsible      *
C  to those vendors for complying with any of the vendors' copyright and   *
C  license restrictions. In particular users must obtain a Runtime license *
C  for Orbix from IONA Technologies for each CPU used in Models-3/CMAQ     *
C  applications.                                                           *
C                                                                          *
C  Portions of I/O API, PAVE, and the model builder are Copyrighted        *
C  1993-1997 by MCNC--North Carolina Supercomputing Center and are         *
C  used with their permissions subject to the above restrictions.          *
C***************************************************************************

C RCS file, release, date & time of last delta, author, state, [and locker]
C $Header: /project/work/rep/PROCAN/src/driver/pa/pa_getirrout.F,v 1.3 1998/06/19 11:38:42 yoj Exp $ 

C what(1) key, module and SID; SCCS file; date and time of last delta:
C @@(#)pa_getirrout.F	1.1 /project/mod3/PROCAN/src/driver/pa/SCCS/s.pa_getirrout.F 04 Jul 1997 14:13:30

      SUBROUTINE GETIRROUT

C***********************************************************************
C
C  FUNCTION: To process the IRR_OUTPUT option 
C
C  PRECONDITIONS: None
C 
C  KEY SUBROUTINES/FUNCTIONS CALLED: GETCHR
C                                    GETWORD
C                                    GETCOEF
C
C  REVISION HISTORY: Prototype created by Jerry Gipson, August, 1996
C                    Modified May, 1997 by Jerry Gipson to be consistent
C                       with beta CTM
C                    Modified Sept, 1997 by Jerry Gipson to be consistent
C                      with targeted CTM
C
C***********************************************************************
      IMPLICIT NONE
      
C..INCLUDES:
      INCLUDE SUBST_IODECL 
      INCLUDE 'PA_GLOBAL.EXT'
      INCLUDE 'PA_PARSE.EXT'
      INCLUDE 'PA_VARS.EXT'
      
C..ARGUMENTS: None
                                        
C..PARAMETERS: None

C..EXTERNAL FUNCTIONS: None

C..SAVED LOCAL VARIABLES: None

C..SCRATCH LOCAL VARIABLES:
      INTEGER TERMNUM   ! Counter for number of terms in cycle
C***********************************************************************

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Get assigned name and check for = sign delimiter
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      NIRROUT = NIRROUT + 1
      IF( NIRROUT .GT. MAXIRROUT ) THEN
         EXITSTAT = 2
         WRITE( MSG, 94000 ) 
         CALL M3MESG( MSG )
         WRITE( MSG, 94500 ) LINNUM, INBUF
         CALL M3MESG( MSG )
         WRITE( MSG, 94020 ) MAXIRROUT
         CALL M3MESG( MSG )
         CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
      ENDIF

      CALL GETWORD
      IRRNAME( NIRROUT ) = WORD
      IRRDESC( NIRROUT ) = WORD

      IF( CHR .NE. '=' ) THEN
         WRITE( MSG, 94040 ) 
         CALL M3MESG( MSG )
         WRITE( MSG, 94500 ) LINNUM, INBUF
         CALL M3MESG( MSG )
         WRITE( MSG, 94520 ) CHR
         CALL M3MESG( MSG )
         CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
      ELSE
         CALL GETCHR
      ENDIF

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Top of loop on terms in output command
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      TERMNUM = 0
   20 CONTINUE
      TERMNUM = TERMNUM + 1
      IF( TERMNUM .GT. MAXOUTTERMS ) THEN
         EXITSTAT = 2
         WRITE( MSG, 94060 ) 
         CALL M3MESG( MSG )
         WRITE( MSG, 94500 ) LINNUM, INBUF
         CALL M3MESG( MSG )
         WRITE( MSG, 94080 ) MAXOUTTERMS
         CALL M3MESG( MSG )
         CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
      ENDIF      

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Get the term's coefficient if there is one
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      CALL GETCOEF( OUTSC( NIRROUT, TERMNUM ) )
      OUTPNFLAG( NIRROUT, TERMNUM ) = ''

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Reaction rate term
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF( CHR .EQ. '<' ) THEN
         OUTTYPE( NIRROUT, TERMNUM ) = 'RXN'
         CALL GETLABEL
         OUTRXLBL( NIRROUT, TERMNUM ) = LABEL
      ELSE
         CALL GETWORD

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Production term
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IF( WORD .EQ. 'PROD' .OR. WORD .EQ. 'NETP' ) THEN
            OUTTYPE( NIRROUT, TERMNUM ) = WORD
            IF( CHR .EQ. '[' ) THEN
               CALL GETLABEL
               OUTSPEC1( NIRROUT, TERMNUM ) = LABEL
            ELSE
               EXITSTAT = 2
               WRITE( MSG, 94100 ) 
               CALL M3MESG( MSG )
               WRITE( MSG, 94500 ) LINNUM, INBUF
               CALL M3MESG( MSG )
               WRITE( MSG, 94520 ) CHR
               CALL M3MESG( MSG )
               CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
            ENDIF

c..FROM option
            OUTSPEC2( NIRROUT, TERMNUM ) = ''
            IF( CHR .EQ. 'F' ) THEN
               CALL GETWORD
               IF( WORD .NE. 'FROM' ) THEN
                  EXITSTAT = 2
                  WRITE( MSG, 94120 ) 
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94500 ) LINNUM, INBUF
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94540 ) WORD
                  CALL M3MESG( MSG )
                  CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ',
     &                          EXITSTAT )
               ENDIF
               IF( CHR .EQ. '[' ) THEN
                  CALL GETLABEL
                  OUTSPEC2( NIRROUT, TERMNUM ) = LABEL
               ELSE
                  EXITSTAT = 2
                  WRITE( MSG, 94100 ) 
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94500 ) LINNUM, INBUF
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94520 ) CHR
                  CALL M3MESG( MSG )
                  CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ',
     &                          EXITSTAT )
               ENDIF
            ENDIF

            OUTOP2( NIRROUT, TERMNUM ) = ''
            OUTSPEC3( NIRROUT, TERMNUM ) = ''

c..AND/OR operator 
            IF( CHR .EQ. 'A' .OR. CHR .EQ. 'O' ) THEN
               CALL GETWORD
               IF( WORD .NE. 'AND' .AND. WORD .NE. 'OR' ) THEN
                  EXITSTAT = 2
                  WRITE( MSG, 94140 ) 
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94500 ) LINNUM, INBUF
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94540 ) WORD
                  CALL M3MESG( MSG )
                  CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ',
     &                          EXITSTAT )
               ELSE
                  OUTOP2( NIRROUT, TERMNUM ) = WORD
                  IF( CHR .EQ. '[' ) THEN
                     CALL GETLABEL
                     OUTSPEC3( NIRROUT, TERMNUM ) = LABEL
                  ELSE
                     EXITSTAT = 2
                     WRITE( MSG, 94100 ) 
                     CALL M3MESG( MSG )
                     WRITE( MSG, 94500 ) LINNUM, INBUF
                     CALL M3MESG( MSG )
                     WRITE( MSG, 94520 ) CHR
                     CALL M3MESG( MSG )
                     CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ',
     &                             EXITSTAT )
                   ENDIF
                ENDIF
             ENDIF

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Loss Term
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         ELSEIF( WORD .EQ. 'LOSS' .OR. WORD .EQ. 'NETL' ) THEN
            OUTTYPE( NIRROUT, TERMNUM ) = WORD
            IF( CHR .EQ. '[' ) THEN
               CALL GETLABEL
               OUTSPEC1( NIRROUT, TERMNUM ) = LABEL
            ELSE
               EXITSTAT = 2
               WRITE( MSG, 94100 ) 
               CALL M3MESG( MSG )
               WRITE( MSG, 94500 ) LINNUM, INBUF
               CALL M3MESG( MSG )
               WRITE( MSG, 94520 ) CHR
               CALL M3MESG( MSG )
               CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
            ENDIF

            OUTOP2(   NIRROUT, TERMNUM ) = ''
            OUTSPEC2( NIRROUT, TERMNUM ) = ''
            OUTSPEC3( NIRROUT, TERMNUM ) = ''

c..AND/OR operator 
            IF( CHR .EQ. 'A' .OR. CHR .EQ. 'O' ) THEN
               CALL GETWORD
               IF( WORD .NE. 'AND' .AND. WORD. NE. 'OR' ) THEN
                  EXITSTAT = 2
                  WRITE( MSG, 94140 ) 
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94500 ) LINNUM, INBUF
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94540 ) WORD
                  CALL M3MESG( MSG )
                  CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ',
     &                          EXITSTAT )
               ELSE
                  OUTOP2( NIRROUT, TERMNUM ) = WORD
                  IF( CHR .EQ. '[' ) THEN
                     CALL GETLABEL
                     OUTSPEC3( NIRROUT, TERMNUM ) = LABEL
                  ELSE
                     EXITSTAT = 2
                     WRITE( MSG, 94100 ) 
                     CALL M3MESG( MSG )
                     WRITE( MSG, 94500 ) LINNUM, INBUF
                     CALL M3MESG( MSG )
                     WRITE( MSG, 94520 ) CHR
                     CALL M3MESG( MSG )
                     CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ',
     &                             EXITSTAT )
                  ENDIF
               ENDIF
            ENDIF

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Net Term
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         ELSEIF( WORD .EQ. 'NET' ) THEN
            OUTTYPE(  NIRROUT, TERMNUM ) = 'NET'
            OUTOP2(   NIRROUT, TERMNUM ) = ''
            OUTSPEC2( NIRROUT, TERMNUM ) = ''
            OUTSPEC3( NIRROUT, TERMNUM ) = ''
            IF( CHR .EQ. '[' ) THEN
               CALL GETLABEL
               OUTSPEC1( NIRROUT, TERMNUM ) = LABEL
            ELSE
               EXITSTAT = 2
               WRITE( MSG, 94100 ) 
               CALL M3MESG( MSG )
               WRITE( MSG, 94500 ) LINNUM, INBUF
               CALL M3MESG( MSG )
               WRITE( MSG, 94520 ) CHR
               CALL M3MESG( MSG )
               CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
            ENDIF

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  The term must be a predefined name
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         ELSE
            OUTTYPE(  NIRROUT, TERMNUM ) = 'NAME'            
            OUTSPEC1( NIRROUT, TERMNUM ) = WORD
            IF( CHR .EQ. '[' ) THEN
               CALL GETLABEL
               IF( LABEL .NE. 'POSONLY' .AND. LABEL .NE. 'NEGONLY' ) 
     &              THEN
                  EXITSTAT = 2
                  WRITE( MSG, 94180 ) 
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94500 ) LINNUM, INBUF
                  CALL M3MESG( MSG )
                  WRITE( MSG, 94540 ) LABEL
                  CALL M3MESG( MSG )
                  CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', 
     &                          EXITSTAT )
               ELSE          
                  OUTPNFLAG( NIRROUT, TERMNUM ) = LABEL
               ENDIF
            ENDIF
         ENDIF
      ENDIF
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Go back and get the next operator, return, or err off
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF( CHR .EQ. '+' .OR. CHR .EQ. '-' ) THEN
         GO TO 20
      ELSEIF( CHR .EQ. ';' ) THEN
         NIRRTERMS( NIRROUT ) = TERMNUM
         CALL GETCHR
         RETURN
      ELSE
         EXITSTAT = 2
         WRITE( MSG, 94200 ) 
         CALL M3MESG( MSG )
         WRITE( MSG, 94500 ) LINNUM, INBUF
         CALL M3MESG( MSG )
         WRITE( MSG, 94520 ) CHR
         CALL M3MESG( MSG )
         CALL M3EXIT( 'GETIRROUT', IZERO, IZERO, ' ', EXITSTAT )
      ENDIF            


C*********************** FORMAT STATEMENTS *****************************


94000 FORMAT( 'ERROR: Maximum number of IRR_OUTPUTs exceeded' )
94020 FORMAT( '       Modify PARAMETER ( MAXIRROUT =', I3,' ) or',
     &              '  decrease the number of IRR_OUTPUT requests' )
94040 FORMAT( 'ERROR: Equal sign expected after IRR_OUTPUT name' )
94060 FORMAT( 'ERROR: Maximum number of terms in an IRR_OUTPUT exceeded' )
94080 FORMAT( '       Modify PARAMETER ( MAXOUTTERMS =', I3,' ) or', 
     &              ' decrease the number of terms in IRR_OUTPUT' )

94100 FORMAT( 'ERROR: A [ must follow PROD/LOSS/NET operators or',
     &               ' FROM/AND/OR options' )
94120 FORMAT( 'ERROR: Only the FROM option can follow the PROD/NETP',
     &               ' operators' ) 
94140 FORMAT( 'ERROR: Only the AND/OR options can follow the FROM',
     &               ' option' )
94160 FORMAT( 'ERROR: Only the AND/OR options can follow the LOSS',
     &                              ' operator' )
94180 FORMAT( 'ERROR: Only POSONLY/NEGONLY options can follow defined',
     &                              ' names' )
94200 FORMAT( 'ERROR: Expecting a +, -, or ; after an IRR_OUTPUT term' ) 

94500 FORMAT( '       Line No. ', I4, ': ', A )
94520 FORMAT( '       Character found: ', A )
94540 FORMAT( '       Word found: ', A )




      END
@


1.1.1.1
log
@CMAQv4_7_1 release
@
text
@@
