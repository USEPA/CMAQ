head     1.1;
branch   1.1.1;
access   ;
symbols  CMAQv4_7_1:1.1.1.1 AMAD:1.1.1;
locks    ; strict;
comment  @c @;


1.1
date     2009.12.10.15.46.21;  author sjr;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2009.12.10.15.46.21;  author sjr;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@
C***********************************************************************
C   Portions of Models-3/CMAQ software were developed or based on      *
C   information from various groups: Federal Government employees,     *
C   contractors working on a United States Government contract, and    *
C   non-Federal sources (including research institutions).  These      *
C   research institutions have given the Government permission to      *
C   use, prepare derivative works, and distribute copies of their      *
C   work in Models-3/CMAQ to the public and to permit others to do     *
C   so.  EPA therefore grants similar permissions for use of the       *
C   Models-3/CMAQ software, but users are requested to provide copies  *
C   of derivative works to the Government without restrictions as to   *
C   use by others.  Users are responsible for acquiring their own      *
C   copies of commercial software associated with Models-3/CMAQ and    *
C   for complying with vendor requirements.  Software copyrights by    *
C   the MCNC Environmental Modeling Center are used with their         *
C   permissions subject to the above restrictions.                     *
C***********************************************************************

C RCS file, release, date & time of last delta, author, state, [and locker]
C $Header: /project/work/rep/ICON/src/input/radmconc/radm_vinterp.F,v 1.5 2002/04/12 14:13:21 yoj Exp $ 

C what(1) key, module and SID; SCCS file; date and time of last delta:
C %W% %P% %G% %U%


      SUBROUTINE VINTERP( LOGUNIT, SDATE, STIME, NCOLS_IN, NROWS_IN,
     &                    NLAYS_IN, NSPCS_IN, COL_LOC, ROW_LOC, CONCIN,
     &                    CONCVI )

C*************************************************************************
C
C   FUNCTION: Interpolates RADM concentrations from the RADM grid to the
C             output Models-3 grid.  If vertical interpolation is needed,
C             either a linear or a rational function method is used.
C             
C  PRECONDITIONS: None
C 
C  KEY SUBROUTINES/FUNCTIONS CALLED: LR_INTERP  
C
C  REVISION HISTORY: Prototype created by Jerry Gipson, January, 1998          
C                    01/24/02 Steve Howard (Jeff Young) - dynamic allocation
C                   
C*************************************************************************

      USE HGRD_DEFN  ! Module to store and load the horizontal grid variables

      IMPLICIT NONE     

C..INCLUDE FILES:
      INCLUDE SUBST_IOPARMS     ! IOAPI parameters
      INCLUDE SUBST_IOFDESC     ! IOAPI file description
      INCLUDE SUBST_IODECL      ! IOAPI declarations
!     INCLUDE SUBST_HGRD_ID     ! Horizontal grid
      INCLUDE SUBST_VGRD_ID     ! Vertical grid
      INCLUDE SUBST_COORD_ID    ! Grid coordinate data

      INCLUDE 'IC_PARMS.EXT'    ! ICON paramters
      INCLUDE 'RADM_SIGMA.EXT'  ! RADM vertical coordinate data

C..ARGUMENTS: None
      INTEGER LOGUNIT      ! Unit number for output log
      INTEGER NCOLS_IN     ! No. of columns in input conc file
      INTEGER NLAYS_IN     ! No. of layers in input conc file
      INTEGER NROWS_IN     ! No. of rows in input conc file
      INTEGER NSPCS_IN     ! No. of species in input conc file
      INTEGER SDATE        ! Date for IC Output
      INTEGER STIME        ! Time for IC output

      INTEGER COL_LOC( NCOLS, NROWS )  ! Output IC col corresponding to
                                       ! a cell in the input CTM file
      INTEGER ROW_LOC( NCOLS, NROWS )  ! Output IC row corresponding to
                                       ! a cell in the input CTM file

      REAL CONCIN(  NROWS_IN, NLAYS_IN, NSPCS_IN, NCOLS_IN )  ! Input conc array
      REAL CONCVI(  NCOLS,    NROWS,    NLAYS,    * )         ! Output IC array

C..PARAMETERS: None

C..EXTERNAL FUNCTIONS:
      LOGICAL ENVYN          ! Gets logical value of an environment variable

C..SAVED LOCAL VARIABLES: None

C..SCRATCH LOCAL VARIABLES:
      CHARACTER*20  CHR1     ! Value of variable 1 in character data
      CHARACTER*20  CHR2     ! Value of variable 1 in character data
      CHARACTER*80  MSG      ! Log message
      CHARACTER*16  PNAME    ! Program Name

      INTEGER C, CIN         ! Loop indices for columns
      INTEGER L              ! Loop index for vertical layers
      INTEGER MXLEV          ! Largest no. of levels
      INTEGER R, RIN         ! Loop indices for rows
      INTEGER STATUS         ! Staus code
      INTEGER V              ! Loop index for variables

      LOGICAL LDEC           ! Flag for monotonic decreasing layer levels
      LOGICAL LINC           ! Flag for monotonic increasing layer levels
      LOGICAL L_IDENTICAL    ! Flag for identical vert coord systems      
      LOGICAL L_RATINT       ! Flag to use rational function interpolation 

      REAL DELY  ! Error estimate for conc interpolated by rational func
      REAL X3    ! Vertical coordinate used in interpolation
      REAL Y     ! Interpolated concentration

      REAL WORKA(  MXLAYS3 )   ! Work array for conc input
      REAL X3_OLD( MXLAYS3 )   ! Old Vertical coordinate values
      
C**********************************************************************
      DATA PNAME / 'RADM_INTERP' /

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Write headers and report vertical grid resolutions
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      WRITE( LOGUNIT, 92000 )

      IF( NLAYS_IN . NE. KMAX ) THEN
         WRITE( LOGUNIT, 92040 ) NLAYS_IN, KMAX
         MSG = 'ERROR: KMAX in RADM_SIGMA.EXT must equal KMAX in RADM'
     &         // ' input files.'
         CALL M3ERR( PNAME, 0, 0, MSG, .TRUE. )
      ENDIF   

      WRITE( LOGUNIT, 92060 )

      WRITE( LOGUNIT, 92080 ) VGDESC( VGTYP_GD )

      WRITE( LOGUNIT, 92100 ) 

      MXLEV = MAX( NLAYS + 1, NLAYS_IN + 1 )

      DO L = 1, MXLEV 

         IF( L .LE. NLAYS + 1 .AND. L .LE. NLAYS_IN + 1 ) THEN
            WRITE( LOGUNIT, 92120 ) L, VGLVS_GD( L ), SIGFIN( L )
         ELSEIF( L .LE. NLAYS + 1 .AND. L .GT. NLAYS_IN + 1 ) THEN
            WRITE( LOGUNIT, 92120 ) L, VGLVS_GD( L )
         ELSEIF( L .GT. NLAYS + 1 .AND. L .LE. NLAYS_IN + 1 ) THEN
            WRITE( LOGUNIT, 92140 ) L, SIGFIN( L )
         ENDIF

      ENDDO     

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Determine type of interpolation to use: linear or rational function
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      L_RATINT = .FALSE.
      MSG = 'Flag for vertical interpolation by rational function'
c      L_RATINT = ENVYN( 'RATIONAL_FUNC', MSG, L_RATINT, STATUS )  
      IF( .NOT. L_RATINT ) THEN
         MSG = 'Vertical interpolation method: Linear'
      ELSE
         MSG = 'Vertical interpolation method: Rational Function.'
      ENDIF

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Check for consistent vertical coordinates
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      L_IDENTICAL  = .TRUE.

      IF( NLAYS .EQ. NLAYS_IN ) THEN
         DO L = 1, NLAYS + 1
            WRITE( CHR1, 94000 ) VGLVS_GD( L )
            WRITE( CHR2, 94000 ) SIGFIN(  L )
            IF( CHR1 .NE. CHR2 ) L_IDENTICAL  = .FALSE.
         ENDDO
      ELSE
         L_IDENTICAL  = .FALSE. 
      ENDIF
            
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  For identical vertical coordinates, map the CTM concs to the output
C  IC array and return
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      IF( L_IDENTICAL ) THEN

         WRITE( LOGUNIT, 92160 ) 

         DO C = 1, NCOLS
            DO R = 1, NROWS
               CIN = COL_LOC( C, R )
               RIN = ROW_LOC( C, R )
               DO L = 1, NLAYS
                  DO V = 1, NSPCS_IN
                     CONCVI( C, R, L, V ) = CONCIN( RIN, L, V, CIN )
                  ENDDO
               ENDDO
            ENDDO
         ENDDO

         RETURN

      ENDIF
         
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  for vertical coords of same type but different resolution, 
c  interpolate/extrapolate by VGLEVS 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc    
      WRITE( LOGUNIT, 92180 ) MSG 

      DO L = 1, NLAYS_IN 
         X3_OLD( L ) = 0.5 * ( SIGFIN ( L ) +  SIGFIN ( L + 1 ) )
      ENDDO

      LINC = .FALSE.
      LDEC = .FALSE.

      IF( SIGFIN ( NLAYS_IN ) .GT. SIGFIN ( 1 ) ) THEN
         LINC = .TRUE.
      ELSE
         LDEC = .TRUE.
      ENDIF

      DO C = 1, NCOLS
         DO R = 1, NROWS
            CIN = COL_LOC( C, R )
            RIN = ROW_LOC( C, R )
            DO V = 1, NSPCS_IN    

               DO L = 1, NLAYS_IN
                  WORKA( L ) = CONCIN( RIN, L, V, CIN )
               ENDDO

               DO L = 1, NLAYS

                  IF( NLAYS_IN .EQ. 1 ) THEN

                     CONCVI( C, R, L, V ) = WORKA( 1 )

                  ELSE

                     X3 = 0.5 * ( VGLVS_GD ( L ) +  VGLVS_GD ( L + 1 ) )

                     IF( LINC .AND. X3 .LE. X3_OLD( 1 ) ) THEN
                        CONCVI( C, R, L, V ) = WORKA( 1 )
                     ELSEIF( LDEC .AND. X3 .GE. X3_OLD( 1 ) ) THEN
                        CONCVI( C, R, L, V ) = WORKA( 1 )
                     ELSEIF( LINC .AND. X3 .GE. X3_OLD( NLAYS_IN ) ) THEN
                        CONCVI( C, R, L, V ) = WORKA( NLAYS_IN )
                     ELSEIF( LDEC .AND. X3 .LE. X3_OLD( NLAYS_IN ) ) THEN
                        CONCVI( C, R, L, V ) = WORKA( NLAYS_IN )
                     ELSE
                        CALL LR_INTERP( L_RATINT, X3_OLD, WORKA, NLAYS_IN,
     &                                  X3, Y, DELY )
                        CONCVI( C, R, L, V ) = Y
                     ENDIF

                  ENDIF

               ENDDO
            ENDDO
         ENDDO
      ENDDO

      RETURN

C************************* FORMAT STATEMENTS ***************************

92000 FORMAT( // 1X, 79( '#' ) 
     &         / 1X, '#  Vertical Interpolation Section '
     &         / 1X, 79( '#' ) ) 


92040 FORMAT( // 5X, 'ERROR: RADM input layers = ', I3, 'RADM_SIGMA.EXT '
     &               'layers = ', I3 )

92060 FORMAT( // 5X, 'WARNING: The vertical grid type of the RADM ',
     &               'input file is assumed to be the same as the '
     &         / 5X, '         type specified in COORD.EXT. The ',
     &               'resolution of each is listed below. ' )

92080 FORMAT( // 5X, 'COORD.EXT vertical grid type: ', A )

92100 FORMAT( // 5X, 'Vertical layer surface values: '
     &         /10X, ' K    COORD.EXT       Input RADM file' )

92120 FORMAT(   10X, I2, 1X, F12.3, 10X, F12.3 )

92140 FORMAT(   10X, I2,       13X, 10X, F12.3 )

92160 FORMAT( // 5X, 'The vertical structure in COORD.EXT is identical'
     &               ' to that of the RADM_SIGMA.EXT. '
     &        // 5X, 'No vertical interpolation necessary.' )

92180 FORMAT( // 5X, A )

94000 FORMAT( 1PE20.4 )

      END
@


1.1.1.1
log
@CMAQv4_7_1 release
@
text
@@
